{"ast":null,"code":"/**\n * Utility functions for handling media in the application\n */\n\n/**\n * Get the base URL for media files\n * @returns {string} The base URL for media files\n */\nexport const getMediaBaseUrl = () => {\n  return process.env.REACT_APP_API_URL || \"http://localhost:8080\";\n};\n\n/**\n * Format a media URL to ensure it's properly formed\n * @param {string} url The raw URL from the backend\n * @returns {string} A properly formatted URL\n */\nexport const formatMediaUrl = url => {\n  if (!url) return null;\n\n  // If it's already an absolute URL, return it as is\n  if (url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n    return url;\n  }\n  const baseUrl = getMediaBaseUrl();\n\n  // If it's a relative URL starting with /uploads/, just prepend the base URL\n  if (url.startsWith(\"/uploads/\")) {\n    return `${baseUrl}${url}`;\n  }\n\n  // If it's a relative URL starting with uploads/, prepend the base URL and a slash\n  if (url.startsWith(\"uploads/\")) {\n    return `${baseUrl}/${url}`;\n  }\n\n  // For other filenames, assume they should be in the uploads directory\n  return `${baseUrl}/uploads/${url}`;\n};\n\n/**\n * Process an array of media items to ensure all URLs are properly formatted\n * @param {Array} mediaItems Array of media objects\n * @returns {Array} Array of media objects with formatted URLs\n */\nexport const processMediaItems = mediaItems => {\n  if (!mediaItems || !Array.isArray(mediaItems)) return [];\n  return mediaItems.map(media => {\n    if (!media) return media;\n    return {\n      ...media,\n      url: formatMediaUrl(media.url)\n    };\n  });\n};\n\n/**\n * Determine if a URL points to an image\n * @param {string} url The URL to check\n * @returns {boolean} True if the URL points to an image\n */\nexport const isImageUrl = url => {\n  if (!url) return false;\n  const lowercaseUrl = url.toLowerCase();\n  return lowercaseUrl.endsWith(\".jpg\") || lowercaseUrl.endsWith(\".jpeg\") || lowercaseUrl.endsWith(\".png\") || lowercaseUrl.endsWith(\".gif\") || lowercaseUrl.endsWith(\".webp\");\n};\n\n/**\n * Determine if a URL points to a video\n * @param {string} url The URL to check\n * @returns {boolean} True if the URL points to a video\n */\nexport const isVideoUrl = url => {\n  if (!url) return false;\n  const lowercaseUrl = url.toLowerCase();\n  return lowercaseUrl.endsWith(\".mp4\") || lowercaseUrl.endsWith(\".webm\") || lowercaseUrl.endsWith(\".ogg\") || lowercaseUrl.endsWith(\".mov\");\n};","map":{"version":3,"names":["getMediaBaseUrl","process","env","REACT_APP_API_URL","formatMediaUrl","url","startsWith","baseUrl","processMediaItems","mediaItems","Array","isArray","map","media","isImageUrl","lowercaseUrl","toLowerCase","endsWith","isVideoUrl"],"sources":["/Users/pereraw.b.n/PAF project/frontend/src/utils/mediaUtils.js"],"sourcesContent":["/**\n * Utility functions for handling media in the application\n */\n\n/**\n * Get the base URL for media files\n * @returns {string} The base URL for media files\n */\nexport const getMediaBaseUrl = () => {\n    return process.env.REACT_APP_API_URL || \"http://localhost:8080\"\n  }\n  \n  /**\n   * Format a media URL to ensure it's properly formed\n   * @param {string} url The raw URL from the backend\n   * @returns {string} A properly formatted URL\n   */\n  export const formatMediaUrl = (url) => {\n    if (!url) return null\n  \n    // If it's already an absolute URL, return it as is\n    if (url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n      return url\n    }\n  \n    const baseUrl = getMediaBaseUrl()\n  \n    // If it's a relative URL starting with /uploads/, just prepend the base URL\n    if (url.startsWith(\"/uploads/\")) {\n      return `${baseUrl}${url}`\n    }\n  \n    // If it's a relative URL starting with uploads/, prepend the base URL and a slash\n    if (url.startsWith(\"uploads/\")) {\n      return `${baseUrl}/${url}`\n    }\n  \n    // For other filenames, assume they should be in the uploads directory\n    return `${baseUrl}/uploads/${url}`\n  }\n  \n  /**\n   * Process an array of media items to ensure all URLs are properly formatted\n   * @param {Array} mediaItems Array of media objects\n   * @returns {Array} Array of media objects with formatted URLs\n   */\n  export const processMediaItems = (mediaItems) => {\n    if (!mediaItems || !Array.isArray(mediaItems)) return []\n  \n    return mediaItems.map((media) => {\n      if (!media) return media\n  \n      return {\n        ...media,\n        url: formatMediaUrl(media.url),\n      }\n    })\n  }\n  \n  /**\n   * Determine if a URL points to an image\n   * @param {string} url The URL to check\n   * @returns {boolean} True if the URL points to an image\n   */\n  export const isImageUrl = (url) => {\n    if (!url) return false\n  \n    const lowercaseUrl = url.toLowerCase()\n    return (\n      lowercaseUrl.endsWith(\".jpg\") ||\n      lowercaseUrl.endsWith(\".jpeg\") ||\n      lowercaseUrl.endsWith(\".png\") ||\n      lowercaseUrl.endsWith(\".gif\") ||\n      lowercaseUrl.endsWith(\".webp\")\n    )\n  }\n  \n  /**\n   * Determine if a URL points to a video\n   * @param {string} url The URL to check\n   * @returns {boolean} True if the URL points to a video\n   */\n  export const isVideoUrl = (url) => {\n    if (!url) return false\n  \n    const lowercaseUrl = url.toLowerCase()\n    return (\n      lowercaseUrl.endsWith(\".mp4\") ||\n      lowercaseUrl.endsWith(\".webm\") ||\n      lowercaseUrl.endsWith(\".ogg\") ||\n      lowercaseUrl.endsWith(\".mov\")\n    )\n  }\n  "],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,MAAMA,eAAe,GAAGA,CAAA,KAAM;EACjC,OAAOC,OAAO,CAACC,GAAG,CAACC,iBAAiB,IAAI,uBAAuB;AACjE,CAAC;;AAED;AACF;AACA;AACA;AACA;AACE,OAAO,MAAMC,cAAc,GAAIC,GAAG,IAAK;EACrC,IAAI,CAACA,GAAG,EAAE,OAAO,IAAI;;EAErB;EACA,IAAIA,GAAG,CAACC,UAAU,CAAC,SAAS,CAAC,IAAID,GAAG,CAACC,UAAU,CAAC,UAAU,CAAC,EAAE;IAC3D,OAAOD,GAAG;EACZ;EAEA,MAAME,OAAO,GAAGP,eAAe,CAAC,CAAC;;EAEjC;EACA,IAAIK,GAAG,CAACC,UAAU,CAAC,WAAW,CAAC,EAAE;IAC/B,OAAO,GAAGC,OAAO,GAAGF,GAAG,EAAE;EAC3B;;EAEA;EACA,IAAIA,GAAG,CAACC,UAAU,CAAC,UAAU,CAAC,EAAE;IAC9B,OAAO,GAAGC,OAAO,IAAIF,GAAG,EAAE;EAC5B;;EAEA;EACA,OAAO,GAAGE,OAAO,YAAYF,GAAG,EAAE;AACpC,CAAC;;AAED;AACF;AACA;AACA;AACA;AACE,OAAO,MAAMG,iBAAiB,GAAIC,UAAU,IAAK;EAC/C,IAAI,CAACA,UAAU,IAAI,CAACC,KAAK,CAACC,OAAO,CAACF,UAAU,CAAC,EAAE,OAAO,EAAE;EAExD,OAAOA,UAAU,CAACG,GAAG,CAAEC,KAAK,IAAK;IAC/B,IAAI,CAACA,KAAK,EAAE,OAAOA,KAAK;IAExB,OAAO;MACL,GAAGA,KAAK;MACRR,GAAG,EAAED,cAAc,CAACS,KAAK,CAACR,GAAG;IAC/B,CAAC;EACH,CAAC,CAAC;AACJ,CAAC;;AAED;AACF;AACA;AACA;AACA;AACE,OAAO,MAAMS,UAAU,GAAIT,GAAG,IAAK;EACjC,IAAI,CAACA,GAAG,EAAE,OAAO,KAAK;EAEtB,MAAMU,YAAY,GAAGV,GAAG,CAACW,WAAW,CAAC,CAAC;EACtC,OACED,YAAY,CAACE,QAAQ,CAAC,MAAM,CAAC,IAC7BF,YAAY,CAACE,QAAQ,CAAC,OAAO,CAAC,IAC9BF,YAAY,CAACE,QAAQ,CAAC,MAAM,CAAC,IAC7BF,YAAY,CAACE,QAAQ,CAAC,MAAM,CAAC,IAC7BF,YAAY,CAACE,QAAQ,CAAC,OAAO,CAAC;AAElC,CAAC;;AAED;AACF;AACA;AACA;AACA;AACE,OAAO,MAAMC,UAAU,GAAIb,GAAG,IAAK;EACjC,IAAI,CAACA,GAAG,EAAE,OAAO,KAAK;EAEtB,MAAMU,YAAY,GAAGV,GAAG,CAACW,WAAW,CAAC,CAAC;EACtC,OACED,YAAY,CAACE,QAAQ,CAAC,MAAM,CAAC,IAC7BF,YAAY,CAACE,QAAQ,CAAC,OAAO,CAAC,IAC9BF,YAAY,CAACE,QAAQ,CAAC,MAAM,CAAC,IAC7BF,YAAY,CAACE,QAAQ,CAAC,MAAM,CAAC;AAEjC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}